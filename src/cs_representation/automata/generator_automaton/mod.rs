use integeriser::HashIntegeriser;
use std::hash::Hash;
use dyck::Bracket;
use cs_representation::BracketContent;
use super::FiniteAutomaton;
use std::rc::Rc;
use util::agenda::Capacity;

pub mod strategy;
pub use self::strategy::{GeneratorStrategy, KellerGenerator, NaiveGenerator, ApproxGenerator};

pub trait GeneratorAutomaton<T>
where
    T: Hash + Clone + Eq
{
    /// Borrows the internal `Integeriser` that is used to integerize `BracketFragements`.
    fn get_integeriser(&self) -> Rc<HashIntegeriser<T>>;

    /// Intersects the language generated by this `GeneratorAutomaton` with a regular language over the
    /// same alphabet an yields an `Iterator` over all words recognised by the resulting automaton.
    fn generate<'a>(&self, fsa: FiniteAutomaton<T>, beam: Capacity) -> Box<Iterator<Item=Vec<T>> + 'a>
    where T: 'a;
}

/// The alphabet Δ(Σ) with respect to a grammar (N, Σ, P, S) consisting of three types of brackets:
/// * ⟨_σ and ⟩_σ for each σ ∈ Σ,
/// * ⟨_{p, j} and ⟩_{p, j} for each p ∈ P and j ∈ fanout(p)
/// * ⟨^{i}_{p, j} and ⟩^i_{p, j} for each p ∈ P, i ∈ rank(p) and j ∈ fanoutᵢ(p).
pub type Delta<T> = Bracket<BracketContent<T>>;
